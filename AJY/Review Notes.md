# Review Notes

# **분리수거장**

### **왜 주민 수를 고려해야 하는가?**

- **모든 아파트 단지에 동일한 주민 수**가 있다면, 단순히 위치의 중앙값에 분리수거장을 설치하면 됨.
- 하지만, **아파트 단지마다 주민 수가 다르다면**:
    - 주민 수가 많은 아파트 단지에 더 가까운 위치에 분리수거장을 설치해야 거리의 합이 최소화됨.
    - 예: 한쪽에 10명이 살고 다른 쪽에 100명이 산다면, 분리수거장은 100명이 사는 쪽에 더 가까워야 함.

# **바닥공사**

### **점화식**

$$
dp[n] = dp[n-1] + dp[n-2]
$$

### **의미**

- **dp[n-1]**: 세로로 1×2 타일 하나를 놓은 경우
- **dp[n-2]**: 가로로 2×1 타일 두 개를 놓은 경우

### **특징**

- 이 점화식은 **피보나치 수열**과 매우 유사함.

### **Dynamic Programming(DP)란?**

### **DP의 정의**

Dynamic Programming은 복잡한 문제를 더 작은 **서브 문제**로 나누어 해결하고, 그 결과를 저장하여 반복 계산을 줄이는 알고리즘 기법입니다.

### **DP의 주요 특징**

1. **중복되는 서브 문제 처리**: 동일한 서브 문제를 여러 번 계산하지 않고, 한 번 계산한 결과를 저장하여 재활용합니다.
2. **최적 부분 구조**: 큰 문제의 최적 해답이 작은 문제들의 최적 해답으로 구성될 수 있습니다.

### **DP의 장점**

- 시간 복잡도를 줄여 효율적인 문제 해결 가능
- 재귀를 최적화하여 메모리 사용량 감소

### **DP의 활용 예시**

1. 피보나치 수열 계산
2. 최단 경로 찾기 (예: 다익스트라 알고리즘)
3. 배낭 문제 (Knapsack Problem)
4. 문자열 비교 및 편집 거리 계산

### **초기값이 필요한 이유**

- 피보나치 방식의 점화식을 사용할 때, **초기값**은 필수입니다.
- 초기값은 문제를 해결하기 위한 기반을 제공하며, 이후 값을 계산하는 데 사용됩니다.

### **초기값 정의**

1. **dp[0] = 1**
    - 가로 길이가 0인 경우 한 가지 방법: 아무것도 놓지 않는 경우
2. **dp[1] = 1**
    - 가로 길이가 1인 경우 한 가지 방법: 세로로 하나 놓기

### **이유**

- 이는 "**아무것도 놓지 않는 경우도 하나의 유효한 방법**"이라고 의도적으로 정의한 것입니다.

### **예시: 피보나치 수열**

### **피보나치 수열 정의**

$$
F(0) = 0
$$

$$
F(1) = 1
$$

$$
F(n) = F(n-1) + F(n-2)
$$

### **재귀적 풀이**

```java
javaint fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

- 이 방식은 **`fib(5`**를 계산할 때, **`fib(3`**와 **`fib(2`**를 여러 번 계산하게 되어 **비효율적**임.

### **효율적인 DP 방식**

→ 한 번 계산한 값을 배열에 저장하여 다시 계산하지 않도록 함.

```java
javaint[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

- 이렇게 하면 한 번씩만 계산해서 훨씬 빠르고 효율적임!

### **DP 방식의 장점**

- 한 번 계산한 값을 재활용하여 중복 계산을 방지.
- 시간 복잡도: O(n) → 재귀보다 훨씬 빠름.
- 공간 복잡도: 배열을 활용해 효율적으로 관리 가능.

### **만약 3*2, 2*3 세로=3 이라면?**

### **타일의 면적**

- 타일의 면적은 모두 **6칸**.
- 따라서 바닥의 면적이 **6의 배수**여야 채울 수 있음.
    
    즉, **N × 3이 6의 배수** → N이 **짝수**여야 함.
    

### **문제 특징 (조금 복잡)**

- 이 문제는 피보나치처럼 단순한 점화식이 아니며, 규칙을 관찰하여 점화식을 세워야 하는 문제입니다.
- 사실, 이 문제는 "**3×N 타일 채우기 문제**"와 비슷한 유형입니다.

### **점화식**

$$
dp[n]=4×dp[n−2]−dp[n−4]
$$

### **초기값:**

- dp = 1
- dp = 3
- dp = 11
- dp = 41

### **예시: N=6인 경우**

1. **3×2 타일을 세로로 배치**: 가능한 경우를 계산.
2. **2×3 타일을 가로로 배치**: 가능한 경우를 계산.
3. 이러한 모든 경우를 점화식으로 계산하여 해결.
- **그만 알아보자... (카카오, 올림피아드)**

# 사전 만들기

### **compareTo() 메서드 설명**

- compareTo() - 문자열을 사전순으로 비교할 때 사용하는 Java의 메서드

### **사용법**

`java문자열1.compareTo(문자열2)`

- 문자열1과 문자열2를 비교하여 **int 값**을 반환합니다.

### **반환값과 의미**

| **반환값** | **의미** |
| --- | --- |
| **`< 0`** (음수) | 문자열1이 문자열2보다 사전순으로 앞에 있음 |
| **`== 0`** | 두 문자열이 같음 |
| **`> 0`** (양수) | 문자열1이 문자열2보다 사전순으로 뒤에 있음 |

# 조합

### 조합 공식

---

$$
\binom{a}{b} = \frac{a!}{b!(a-b)!} 
$$

- 이를 곱셈 형태로 바꾸면 계산이 더 효율적이에요:

$$
\binom{a}{b} = \frac{a(a-1)(a-2)\cdots(a-b+1)}{b!}
$$

---

### 예시: a = 5, b = 3

$$
\binom{5}{3} = \frac{5!}{3!(5-3)!} = \frac{5 \cdot 4 \cdot 3 \cdot 2 \cdot 1}{(3 \cdot 2 \cdot 1)(2 \cdot 1)} = \frac{5 \cdot 4 \cdot 3}{3 \cdot 2 \cdot 1} = \frac{60}{6} = 10
$$

여기서 마지막 항인 3은:

$$
a - b + 1 = 5 - 3 + 1 = 3
$$

---