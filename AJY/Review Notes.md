# Review Notes

# **분리수거장**

### **왜 주민 수를 고려해야 하는가?**

- **모든 아파트 단지에 동일한 주민 수**가 있다면, 단순히 위치의 중앙값에 분리수거장을 설치하면 됨.
- 하지만, **아파트 단지마다 주민 수가 다르다면**:
    - 주민 수가 많은 아파트 단지에 더 가까운 위치에 분리수거장을 설치해야 거리의 합이 최소화됨.
    - 예: 한쪽에 10명이 살고 다른 쪽에 100명이 산다면, 분리수거장은 100명이 사는 쪽에 더 가까워야 함.

# **바닥공사**

### **점화식**

$$
dp[n] = dp[n-1] + dp[n-2]
$$

### **의미**

- **dp[n-1]**: 세로로 1×2 타일 하나를 놓은 경우
- **dp[n-2]**: 가로로 2×1 타일 두 개를 놓은 경우

### **특징**

- 이 점화식은 **피보나치 수열**과 매우 유사함.

### **Dynamic Programming(DP)란?**

### **DP의 정의**

Dynamic Programming은 복잡한 문제를 더 작은 **서브 문제**로 나누어 해결하고, 그 결과를 저장하여 반복 계산을 줄이는 알고리즘 기법입니다.

### **DP의 주요 특징**

1. **중복되는 서브 문제 처리**: 동일한 서브 문제를 여러 번 계산하지 않고, 한 번 계산한 결과를 저장하여 재활용합니다.
2. **최적 부분 구조**: 큰 문제의 최적 해답이 작은 문제들의 최적 해답으로 구성될 수 있습니다.

### **DP의 장점**

- 시간 복잡도를 줄여 효율적인 문제 해결 가능
- 재귀를 최적화하여 메모리 사용량 감소

### **DP의 활용 예시**

1. 피보나치 수열 계산
2. 최단 경로 찾기 (예: 다익스트라 알고리즘)
3. 배낭 문제 (Knapsack Problem)
4. 문자열 비교 및 편집 거리 계산

### **초기값이 필요한 이유**

- 피보나치 방식의 점화식을 사용할 때, **초기값**은 필수입니다.
- 초기값은 문제를 해결하기 위한 기반을 제공하며, 이후 값을 계산하는 데 사용됩니다.

### **초기값 정의**

1. **dp[0] = 1**
    - 가로 길이가 0인 경우 한 가지 방법: 아무것도 놓지 않는 경우
2. **dp[1] = 1**
    - 가로 길이가 1인 경우 한 가지 방법: 세로로 하나 놓기

### **이유**

- 이는 "**아무것도 놓지 않는 경우도 하나의 유효한 방법**"이라고 의도적으로 정의한 것입니다.

### **예시: 피보나치 수열**

### **피보나치 수열 정의**

$$
F(0) = 0
$$

$$
F(1) = 1
$$

$$
F(n) = F(n-1) + F(n-2)
$$

### **재귀적 풀이**

```java
javaint fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

- 이 방식은 **`fib(5`**를 계산할 때, **`fib(3`**와 **`fib(2`**를 여러 번 계산하게 되어 **비효율적**임.

### **효율적인 DP 방식**

→ 한 번 계산한 값을 배열에 저장하여 다시 계산하지 않도록 함.

```java
javaint[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

- 이렇게 하면 한 번씩만 계산해서 훨씬 빠르고 효율적임!

### **DP 방식의 장점**

- 한 번 계산한 값을 재활용하여 중복 계산을 방지.
- 시간 복잡도: O(n) → 재귀보다 훨씬 빠름.
- 공간 복잡도: 배열을 활용해 효율적으로 관리 가능.

### **만약 3*2, 2*3 세로=3 이라면?**

### **타일의 면적**

- 타일의 면적은 모두 **6칸**.
- 따라서 바닥의 면적이 **6의 배수**여야 채울 수 있음.
    
    즉, **N × 3이 6의 배수** → N이 **짝수**여야 함.
    

### **문제 특징 (조금 복잡)**

- 이 문제는 피보나치처럼 단순한 점화식이 아니며, 규칙을 관찰하여 점화식을 세워야 하는 문제입니다.
- 사실, 이 문제는 "**3×N 타일 채우기 문제**"와 비슷한 유형입니다.

### **점화식**

$$
dp[n]=4×dp[n−2]−dp[n−4]
$$

### **초기값:**

- dp = 1
- dp = 3
- dp = 11
- dp = 41

### **예시: N=6인 경우**

1. **3×2 타일을 세로로 배치**: 가능한 경우를 계산.
2. **2×3 타일을 가로로 배치**: 가능한 경우를 계산.
3. 이러한 모든 경우를 점화식으로 계산하여 해결.
- **그만 알아보자... (카카오, 올림피아드)**

# 사전 만들기

### **compareTo() 메서드 설명**

- compareTo() - 문자열을 사전순으로 비교할 때 사용하는 Java의 메서드

### **사용법**

`java문자열1.compareTo(문자열2)`

- 문자열1과 문자열2를 비교하여 **int 값**을 반환합니다.

### **반환값과 의미**

| **반환값** | **의미** |
| --- | --- |
| **`< 0`** (음수) | 문자열1이 문자열2보다 사전순으로 앞에 있음 |
| **`== 0`** | 두 문자열이 같음 |
| **`> 0`** (양수) | 문자열1이 문자열2보다 사전순으로 뒤에 있음 |

# 조합

### 조합 공식

---

$$
\binom{a}{b} = \frac{a!}{b!(a-b)!} 
$$

- 이를 곱셈 형태로 바꾸면 계산이 더 효율적이에요:

$$
\binom{a}{b} = \frac{a(a-1)(a-2)\cdots(a-b+1)}{b!}
$$

---

### 예시: a = 5, b = 3

$$
\binom{5}{3} = \frac{5!}{3!(5-3)!} = \frac{5 \cdot 4 \cdot 3 \cdot 2 \cdot 1}{(3 \cdot 2 \cdot 1)(2 \cdot 1)} = \frac{5 \cdot 4 \cdot 3}{3 \cdot 2 \cdot 1} = \frac{60}{6} = 10
$$

여기서 마지막 항인 3은:

$$
a - b + 1 = 5 - 3 + 1 = 3
$$

---

# 배수만들기

### 알고리즘

## **알고리즘 단계**

1. **정렬 및 조합 생성**
    - 주어진 정수들을 내림차순으로 정렬하여 가장 큰 수를 만들 수 있도록 합니다.
        
        ```
                        int temp = digits[j];
                        digits[j] = digits[j + 1];
                        digits[j + 1] = temp;
        
        ```
        
        - Array.sort() 되나?
    - 0을 제외한 나머지 정수들을 조합하여 가능한 모든 순열을 생성합니다.
        - digits[0] == 0
2. **3의 배수 확인**
    - 각 순열의 합이 3의 배수인지 확인합니다. 3의 배수라면, 각 자리 수의 합이 3의 배수여야 합니다.
        - totalSum % 3 != 0
        - totalSum += digits[i]
3. **100의 배수 확인**
    - 각 순열의 마지막 두 자리가 00이거나 100의 배수인지 확인합니다.
        - digits[i] == 0, zeroCount++
4. **300의 배수 생성**
    - 3의 배수이고 100의 배수인 경우, 해당 순열을 사용하여 가장 큰 300의 배수를 생성합니다.
5. **결과 출력**
    - 생성된 300의 배수가 가장 크면 이를 출력합니다. 만약 300의 배수를 만들 수 없다면 -1을 출력합니다.

# 커트라인 정하기

```java
 int minScore = IntStream.of(scores).min().orElse(0);
```

- 점수의 최솟값을 구해 조건을 만족하지 못할 경우 출력용 기본값 설정
- 예: [20, 30, 100] -> 20
- `IntStream`은 Java에서 **기본형 `int` 값들을 처리하는 스트림(Stream)** 입니다.
- `Stream<Integer>`는 래퍼 클래스(Integer)를 사용하지만,
    
    `IntStream`은 기본형(int)을 직접 다루기 때문에 **성능적으로 더 효율적**입니다.
    

| 메서드 | 설명 |
| --- | --- |
| `.of(int...)` | int 배열 또는 값들로 IntStream 생성 |
| `.min()` | 최솟값 (OptionalInt로 반환됨) |
| `.max()` | 최댓값 (OptionalInt로 반환됨) |
| `.sum()` | 합계 |
| `.average()` | 평균 (OptionalDouble로 반환됨) |
| `.filter()` | 조건에 맞는 값만 추출 |
| `.map()` | 각 값을 변형 |
| `.forEach()` | 각 요소에 대해 작업 수행 |

## 🎯 `orElse()`란?

- `.min()`, `.average()` 등은 **Optional 객체**를 반환합니다.
- 값이 없을 때 기본값을 주고 싶으면 `.orElse(기본값)` 사용!

## ✅ Optional이란?

- `Optional<T>`는 **"값이 있을 수도, 없을 수도 있다"** 는 것을 명시적으로 표현하는 객체입니다.
- `null`을 직접 사용하는 대신 `Optional`을 사용하면 **NullPointerException을 방지**할 수 있습니다.
- `T`는 제네릭 타입입니다. (`String`, `Integer`, `User`, ...)

## ✅ 제네릭이란?

- **제네릭(Generic)** 은 클래스나 메서드를 선언할 때 **타입을 파라미터처럼 일반화**해서 작성할 수 있게 하는 기능입니다.
- 다양한 타입에 대해 **재사용 가능한 코드**를 만들 수 있습니다.

## ✅ NullPointerException이란?

- `NullPointerException`은 Java에서 **null 값을 참조하려고 할 때 발생하는 런타임 예외**입니다.
- 가장 흔하게 발생하는 예외 중 하나로, **null 객체에 접근하거나 메서드를 호출할 때** 발생합니다.

# **분수를 소수로**

## ✅ `BigDecimal`을 사용한 정확한 분수 소수화 방법

### 💡 목적

Java에서 `double`이나 `float`을 사용할 경우 발생하는 **실수 오차 문제**를 해결하기 위해 `BigDecimal`을 사용하여 분수를 정확하게 소수로 변환한다.

---

### ✅ 핵심 요약

| 항목 | 설명 |
| --- | --- |
| **정밀도 보장** | `BigDecimal`을 사용하면 부동소수점 오차 없이 정밀한 실수 연산 가능 |
| **소수 자리 지정** | `divide(BigDecimal, int scale, RoundingMode)`를 사용하여 소수점 이하 자릿수를 정확히 지정하고 반올림 처리 가능 |
| **일반 문자열 출력** | `toPlainString()`을 사용하면 과학적 표기법 없이 일반적인 소수 형태로 출력 |
| **자동 패딩 처리** | 예: `0.320`처럼 소수점 이하 `n`자리까지 `0`을 포함한 정확한 출력 가능 |

---

### 🧪 예시 코드

```java
java
복사편집
BigDecimal p = new BigDecimal("10555");
BigDecimal q = new BigDecimal("33000");
int n = 3;

BigDecimal result = p.divide(q, n, RoundingMode.HALF_UP);
System.out.println(result.toPlainString());  // 출력: 0.320

```

---

### 📌 참고 사항

- `scale`은 소수점 이하 출력할 자릿수를 의미
- `RoundingMode.HALF_UP`은 반올림 방식을 지정 (`5` 이상이면 올림)
- 숫자가 매우 크거나 반복 소수일 경우에도 정확한 결과 제공

# **문서 통계**

### 📌 `String line = scanner.nextLine();`

- **설명**: 한 줄 전체를 입력받을 때 사용
- **특징**
    - 공백 포함하여 한 줄 전체를 입력으로 받음
    - `next()`는 공백 전까지만 읽기 때문에, **공백이 포함된 문장을 읽을 땐 `nextLine()`을 사용해야 함**
- **예시**
    
    ```java
    java
    복사편집
    Scanner scanner = new Scanner(System.in);
    String line = scanner.nextLine(); // "Hello World" 입력 시 → "Hello World"
    
    ```
    

---

### 📌 `replace(" ", "")`

- **설명**: 문자열 내의 공백을 모두 제거
- **사용 목적**: **공백을 제외한 글자 수 계산** 시 유용
- **문법**
    
    ```java
    java
    복사편집
    String noSpace = line.replace(" ", "");
    
    ```
    
- **예시**
    
    ```java
    java
    복사편집
    String line = "Coding Masters";
    String noSpace = line.replace(" ", ""); // "CodingMasters"
    int length = noSpace.length(); // 13
    
    ```
    

---

### 📌 `line.trim().split("\\s+")`

- **설명**
    - `trim()`은 문자열 양쪽 끝의 공백 제거
    - `split("\\s+")`는 **하나 이상의 공백을 기준으로 문자열을 분리** (단어 단위로 나누기)
- **사용 목적**: **단어 수를 정확하게 세기 위해 사용**
- **정규표현식 `\\s+`**
    - `\\s`는 공백 문자 (space, tab 등)
    - `+`는 하나 이상
- **예시**
    
    ```java
    java
    복사편집
    String line = "A   B C";
    String[] words = line.trim().split("\\s+"); // ["A", "B", "C"]
    int wordCount = words.length; // 3
    
    ```
    

# 피보나치 피보나치 수열

### 🔍 문제 설명

- **피보나치 수열**: 1, 1, 2, 3, 5, 8, ...
- **피보나치 피보나치 수열**: 피보나치 수열의 각 항을 그 수만큼 반복
    - 예: 1, 1, 2, 2, 3, 3, 3, 5, 5, 5, 5, 5, ...

> 주어진 정수 a와 b에 대해,
> 
> 
> **피보나치 피보나치 수열의 a번째 항부터 b번째 항까지의 합을 구하는 프로그램**
> 

---

### 💡 핵심 아이디어

- 일반 피보나치 수를 `n`이라 할 때, `n`을 **`n`번 추가**하여 새로운 수열을 생성
- 그 후 인덱스 `a`부터 `b`까지 합산

### 📌 주요 포인트 설명

| 포인트 | 설명 |
| --- | --- |
| `List<Integer> fib` | 피보나치 피보나치 수열을 저장할 리스트 |
| `fib.add()` | 해당 피보나치 수를 그 수만큼 리스트에 추가 |
| `fib.get(i)` | i번째 항의 값을 가져옴 |
| `sum += fib.get(i)` | a~b 항까지의 합 계산 |